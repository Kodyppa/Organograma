<!DOCTYPE html>
<html lang="pt">
<head>
  <meta charset="utf-8">
  <title>Organograma do Ministério da Saúde</title>
  <meta http-equiv="Content-Security-Policy" content="
    default-src 'self';
    script-src 'self' 'unsafe-inline' 'unsafe-eval' https://d3js.org https://cdnjs.cloudflare.com;
    style-src 'self' 'unsafe-inline';
    img-src 'self' data:;
  ">
  <style>
    body {
      font-family: Arial, sans-serif;
      margin: 20px;
    }
    h1 {
      color: #2C73B4;
      border-bottom: 2px solid #2C73B4;
      padding-bottom: 10px;
    }
    .ms-header {
      display: flex;
      align-items: center;
      margin-bottom: 20px;
    }
    .ms-logo {
      width: 60px;
      height: 60px;
      background-color: #2C73B4;
      border-radius: 50%;
      display: flex;
      align-items: center;
      justify-content: center;
      color: white;
      font-weight: bold;
      margin-right: 15px;
    }
    #error-message {
      color: red;
      margin-bottom: 10px;
      font-weight: bold;
    }
    .controls {
      margin-bottom: 20px;
    }
    button {
      padding: 8px 15px;
      background-color: #2C73B4;
      color: white;
      border: none;
      border-radius: 4px;
      cursor: pointer;
      margin-right: 10px;
      margin-bottom: 10px;
    }
    button:hover {
      background-color: #1a5a94;
    }
    #chart-container {
      border: 1px solid #ccc;
      padding: 10px;
      overflow: auto;
    }
    .depth-0 rect { fill: #e6f0fa; }
    .depth-1 rect { fill: #d1e5f5; }
    .depth-2 rect { fill: #bdd9f0; }
    .depth-3 rect { fill: #a8ceeb; }
    .depth-4 rect { fill: #93c3e6; }
    .node title {
      font-size: 12px;
    }
    .node circle {
      cursor: pointer;
    }
    .node text {
      font-size: 12px;
      font-family: Arial, sans-serif;
    }
    
    .node text tspan {
      fill: #333;
    }
    
    .node text tspan.sigla {
      font-weight: bold;
      fill: #2C73B4;
    }
    
    path.link {
      fill: none;
      stroke: #ccc;
      stroke-width: 2px;
    }
  </style>
</head>
<body>
  <div class="ms-header">
    <div class="ms-logo">MS</div>
    <h1>Organograma do Ministério da Saúde</h1>
  </div>

  <div id="error-message"></div>

  <div class="controls">
    <input type="file" id="file-input" accept=".csv" style="margin-bottom: 10px; display: block;">
    <button id="expand-all-btn">Expandir Todos</button>
    <button id="collapse-all-btn">Recolher Todos</button>
    <button id="download-btn">Baixar SVG</button>
    <button id="zoomIn-btn">Ampliar (+)</button>
    <button id="zoomOut-btn">Reduzir (-)</button>
    <button id="resetZoom-btn">Resetar Zoom</button>
  </div>

  <div id="chart-container"></div>

  <script src="https://cdnjs.cloudflare.com/ajax/libs/d3/7.8.5/d3.min.js"></script>
  <script>
    const margin = {top: 40, right: 150, bottom: 40, left: 150},
          width = 3600 - margin.left - margin.right,
          height = 1200 - margin.top - margin.bottom;

    let svg, root, i = 0, duration = 750;
    let treemap, zoom;

    function buildHierarchy(data) {
      console.log("Dados recebidos:", data);
      
      // Criar o nó raiz fixo para o Ministério da Saúde
      const root = {
        name: "Ministério da Saúde",
        sigla: "MS",
        children: [],
        image: "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCAxMDAgMTAwIj48Y2lyY2xlIGN4PSI1MCIgY3k9IjUwIiByPSI0NSIgZmlsbD0iIzJDNzNCNCIvPjx0ZXh0IHg9IjUwIiB5PSI2NSIgZm9udC1mYW1pbHk9IkFyaWFsIiBmb250LXNpemU9IjQwIiBmaWxsPSJ3aGl0ZSIgdGV4dC1hbmNob3I9Im1pZGRsZSI+TVM8L3RleHQ+PC9zdmc+" // Logo MS em SVG base64
      };
      
      const nodeMap = {};
      nodeMap["1"] = root;

      // Ordenar os dados para garantir que os pais sejam processados antes dos filhos
      data.sort((a, b) => {
        const subA = String(a["SUBORDINAÇÃO"] || "").trim().split('.').length;
        const subB = String(b["SUBORDINAÇÃO"] || "").trim().split('.').length;
        return subA - subB;
      });

      data.forEach(d => {
        const sub = String(d["SUBORDINAÇÃO"] || "").trim();
        
        console.log("Processando nó:", d["UNIDADE"], "Subordinação:", sub);
        
        const node = {
          name: d["UNIDADE"],
          sigla: d["SIGLA"] || "",
          children: []
        };

        // Adicionar imagem à Secretaria-Executiva
        if (d["UNIDADE"] === "Secretaria-Executiva") {
          node.image = "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA1MDAgNTAwIj48cmVjdCB3aWR0aD0iNTAwIiBoZWlnaHQ9IjUwMCIgZmlsbD0iIzJFNzUyOCIvPjxwYXRoIGQ9Ik0xNTAgMTUwIHYxMDAgaDEwMCB2LTEwMCBoLTEwMCB6IE0yNTAgMTUwIHYxMDAgaDEwMCB2LTEwMCBoLTEwMCB6IE0xNTAgMjUwIHYxMDAgaDEwMCB2LTEwMCBoLTEwMCB6IE0yNTAgMjUwIHYxMDAgaDEwMCB2LTEwMCBoLTEwMCB6IiBmaWxsPSJ3aGl0ZSIvPjxwYXRoIGQ9Ik0xNTAgMTUwIGwxMDAgMCBsMCAxMDAgbC0xMDAgMCB6IE0yNTAgMTUwIGwxMDAgMCBsMCAxMDAgbC0xMDAgMCB6IE0xNTAgMjUwIGwxMDAgMCBsMCAxMDAgbC0xMDAgMCB6IE0yNTAgMjUwIGwxMDAgMCBsMCAxMDAgbC0xMDAgMCB6IiBzdHJva2U9IndoaXRlIiBzdHJva2Utd2lkdGg9IjIiIGZpbGw9Im5vbmUiLz48cGF0aCBkPSJNMjUwIDE1MCBjMTAgMCAxMCAxMCAwIDEwIGwtMTAgMCBjLTEwIDAgLTEwIC0xMCAwIC0xMCB6IE0yNTAgMjUwIGMxMCAwIDEwIDEwIDAgMTAgbC0xMCAwIGMtMTAgMCAtMTAgLTEwIDAgLTEwIHogTTI1MCAxNTAgYzEwIDAgMTAgMTAgMCAxMCBsLTEwIDAgYy0xMCAwIC0xMCAtMTAgMCAtMTAgeiIgZmlsbD0id2hpdGUiLz48L3N2Zz4=";
        }

        // Se a subordinação for 1, adiciona diretamente como filho da raiz
        if (sub === "1") {
          root.children.push(node);
          nodeMap[sub] = node;
          return;
        }
        
        nodeMap[sub] = node;
        
        const parts = sub.split('.');
        if (parts.length > 1) {
          parts.pop();
          const parentCode = parts.join('.');
          console.log("Buscando pai:", parentCode);
          
          if (nodeMap[parentCode]) {
            console.log("Pai encontrado:", nodeMap[parentCode].name);
            nodeMap[parentCode].children.push(node);
          } else {
            console.warn(`Pai não encontrado para: ${sub} (${d["UNIDADE"]})`);
            root.children.push(node);
          }
        } else {
          console.log("Adicionando nó direto à raiz:", d["UNIDADE"]);
          root.children.push(node);
        }
      });

      console.log("Hierarquia construída:", root);
      return root;
    }

    function loadCSVFile() {
      const fileInput = document.getElementById('file-input');
      const file = fileInput.files[0];
      
      if (!file) {
        document.getElementById('error-message').textContent = "Por favor, selecione um arquivo CSV.";
        return;
      }

      const reader = new FileReader();
      reader.onload = function(event) {
        const csvData = event.target.result;
        try {
          const data = d3.csvParse(csvData);
          console.log("CSV parseado:", data);
          
          if (!data || data.length === 0) {
            document.getElementById('error-message').textContent = "Arquivo CSV vazio ou inválido.";
            return;
          }

          // Verificar se as colunas necessárias existem (considerando possíveis encodings diferentes)
          const columns = data.columns.map(col => col.normalize('NFD').replace(/[\u0300-\u036f]/g, ""));
          const hasSubordinacao = columns.some(col => 
            col.toUpperCase() === "SUBORDINACAO" || 
            col.toUpperCase() === "SUBORDINAÇÃO" || 
            col.toUpperCase() === "SUBORDINAO"
          );
          const hasUnidade = columns.some(col => col.toUpperCase() === "UNIDADE");
          const hasSigla = columns.some(col => col.toUpperCase() === "SIGLA");

          if (!hasSubordinacao || !hasUnidade || !hasSigla) {
            document.getElementById('error-message').textContent = 
              "Colunas obrigatórias ausentes no CSV. O arquivo deve conter as colunas: SUBORDINAÇÃO, UNIDADE e SIGLA";
            return;
          }

          // Normalizar os nomes das colunas no objeto data
          data.forEach(d => {
            if (d["SUBORDINAO"]) {
              d["SUBORDINAÇÃO"] = d["SUBORDINAO"];
              delete d["SUBORDINAO"];
            }
          });

          const hierarchy = buildHierarchy(data);
          drawChart(hierarchy);
        } catch (error) {
          console.error("Erro ao processar CSV:", error);
          document.getElementById('error-message').textContent = 
            `Erro ao processar o arquivo CSV: ${error.message}`;
        }
      };
      
      reader.onerror = function() {
        document.getElementById('error-message').textContent = "Erro ao ler o arquivo CSV.";
      };
      
      // Definir o encoding correto para Windows-1252
      reader.readAsText(file, "Windows-1252");
    }

    function drawChart(builtHierarchy) {
      document.getElementById('error-message').textContent = '';
      document.getElementById('chart-container').innerHTML = '';

      const svgContainer = d3.select("#chart-container").append("svg")
          .attr("width", "100%")
          .attr("height", "100%")
          .attr("viewBox", `0 0 ${width + margin.left + margin.right} ${height + margin.top + margin.bottom}`);

      zoom = d3.zoom()
        .scaleExtent([0.1, 3])
        .on("zoom", (event) => {
          svg.attr("transform", event.transform);
        });
      svgContainer.call(zoom);

      svg = svgContainer.append("g")
          .attr("transform", `translate(${margin.left},${margin.top})`);

      treemap = d3.tree()
        .size([width, height])
        .separation((a, b) => {
          if (a.parent == b.parent) {
            return 3;
          }
          return 4;
        });

      root = d3.hierarchy(builtHierarchy);
      root.x0 = width / 2;
      root.y0 = 0;

      svgContainer.call(zoom.transform, d3.zoomIdentity.scale(0.3).translate(width/2, 0));

      update(root);
    }

    function collapse(d) {
      if (d.children) {
        d._children = d.children;
        // Armazenar o estado dos filhos antes de colapsar
        d._children.forEach(child => {
          if (child.children) {
            child._children = child.children;
            child.children = null;
          }
        });
        d.children = null;
      }
    }

    function expandAll(d) {
      if (d._children) {
        d.children = d._children;
        d._children = null;
        d.children.forEach(expandAll);
      }
    }

    function calculateNodeSize(d) {
      // Definir tamanho fixo para todas as caixas
      return {
        width: 300,  // Aumentado de 200 para 300
        height: 120  // Tamanho fixo para todas as caixas
      };
    }

    function wrapText(text, width) {
      text.each(function() {
        const text = d3.select(this);
        const words = text.text().split(/\s+/).reverse();
        const lineHeight = 1.2;
        const y = text.attr("y");
        const dy = parseFloat(text.attr("dy"));
        let tspan = text.text(null).append("tspan").attr("x", 0).attr("y", y).attr("dy", dy + "em");
        let line = [];
        let lineNumber = 0;
        let word;
        
        while (word = words.pop()) {
          line.push(word);
          tspan.text(line.join(" "));
          if (tspan.node().getComputedTextLength() > (width - 40)) {  // Margem interna para o texto
            line.pop();
            tspan.text(line.join(" "));
            line = [word];
            tspan = text.append("tspan")
                .attr("x", 0)
                .attr("y", y)
                .attr("dy", ++lineNumber * lineHeight + dy + "em")
                .text(word);
          }
        }
      });
    }

    function update(source) {
      const treeData = treemap(root);
      const nodes = treeData.descendants();
      const links = treeData.descendants().slice(1);

      nodes.forEach(d => { 
        d.y = d.depth * 400;
        
        if (d.parent) {
          const siblings = d.parent.children;
          const index = siblings.indexOf(d);
          const totalSiblings = siblings.length;
          
          if (totalSiblings > 1) {
            const siblingSpacing = 400;
            const totalWidth = (totalSiblings - 1) * siblingSpacing;
            const startX = d.parent.x - totalWidth / 2;
            d.x = startX + index * siblingSpacing;
          }
        }
      });

      const node = svg.selectAll('g.node')
          .data(nodes, d => d.id || (d.id = ++i));

      const nodeEnter = node.enter().append('g')
          .attr('class', d => `node depth-${d.depth}`)
          .attr("transform", d => `translate(${source.x0},${source.y0})`);

      // Adicionar imagens acima das caixas
      const imageGroup = nodeEnter.append('g')
          .attr('class', 'image-group')
          .style('display', d => d.data.image ? null : 'none');

      imageGroup.append('image')
          .attr('x', d => -40) // Aumentado para centralizar melhor
          .attr('y', d => -calculateNodeSize(d).height/2 - 90) // Aumentado o espaço acima da caixa
          .attr('width', 80) // Aumentado o tamanho
          .attr('height', 80) // Aumentado o tamanho
          .attr('href', d => d.data.image)
          .style('opacity', 1); // Garantir que a imagem seja visível

      nodeEnter.append('rect')
          .attr('width', d => calculateNodeSize(d).width)
          .attr('height', d => calculateNodeSize(d).height)
          .attr('x', d => -calculateNodeSize(d).width / 2)
          .attr('y', d => -calculateNodeSize(d).height / 2)
          .attr('rx', 10)
          .attr('ry', 10)
          .style("fill", d => d._children ? "lightsteelblue" : "#fff")
          .style("stroke", "#2C73B4")
          .style("stroke-width", "2px");

      const textGroup = nodeEnter.append('g')
          .attr('class', 'text-group');

      textGroup.append('text')
          .attr("text-anchor", "middle")
          .attr("y", -20)
          .attr("dy", ".35em")
          .text(d => d.data.name)
          .call(wrapText, 260);

      textGroup.append('text')
          .attr("class", "sigla")
          .attr("text-anchor", "middle")
          .attr("y", 30)
          .attr("dy", ".35em")
          .text(d => d.data.sigla || "")
          .style("font-weight", "bold")
          .style("fill", "#2C73B4");

      // Criar um grupo para o botão de expansão/contração
      const expandButton = nodeEnter.append('g')
          .attr('class', 'expand-button')
          .style('cursor', 'pointer')
          .style('display', d => (d.children || d._children) ? null : 'none')
          .on('click', (event, d) => {
            event.stopPropagation();
            if (d.children) {
              // Se já está expandido, colapsa este nó e todos abaixo dele
              collapse(d);
            } else if (d._children) {
              // Se está colapsado, expande apenas um nível
              d.children = d._children;
              d._children = null;
            }
            update(d);
          });

      expandButton.append('circle')
          .attr('r', 8)
          .attr('cx', d => calculateNodeSize(d).width / 2 - 15)
          .attr('cy', 0)
          .attr('fill', '#fff')
          .attr('stroke', '#2C73B4')
          .attr('stroke-width', 2);

      expandButton.append('text')
          .attr('x', d => calculateNodeSize(d).width / 2 - 15)
          .attr('y', 0)
          .attr('dy', '0.3em')
          .attr('text-anchor', 'middle')
          .attr('font-size', '12px')
          .attr('font-weight', 'bold')
          .text(d => d.children ? '-' : '+');

      nodeEnter.append('title')
          .text(d => `${d.data.name} (${d.data.sigla})`);

      const nodeUpdate = nodeEnter.merge(node);
      nodeUpdate.transition()
          .duration(duration)
          .attr("transform", d => `translate(${d.x},${d.y})`);

      // Atualizar posição das imagens durante a transição
      nodeUpdate.select('.image-group')
          .style('display', d => d.data.image ? null : 'none');

      nodeUpdate.select("rect")
          .style("fill", d => d._children ? "lightsteelblue" : "#fff");

      // Atualizar o texto do botão de expansão
      nodeUpdate.select('.expand-button text')
          .text(d => d.children ? '-' : '+');

      const nodeExit = node.exit().transition()
          .duration(duration)
          .attr("transform", d => `translate(${source.x},${source.y})`)
          .remove();

      nodeExit.select("rect")
          .attr('width', 1e-6)
          .attr('height', 1e-6);

      nodeExit.select("text")
          .style('fill-opacity', 1e-6);

      const link = svg.selectAll('path.link')
          .data(links, d => d.id);

      const linkEnter = link.enter().insert('path', "g")
          .attr("class", "link")
          .attr('d', d => {
            const o = { x: source.x0, y: source.y0 };
            return diagonal(o, o);
          });

      const linkUpdate = linkEnter.merge(link);
      linkUpdate.transition()
          .duration(duration)
          .attr('d', d => diagonal(d, d.parent));

      const linkExit = link.exit().transition()
          .duration(duration)
          .attr('d', d => {
            const o = { x: source.x, y: source.y };
            return diagonal(o, o);
          })
          .remove();

      nodes.forEach(d => {
        d.x0 = d.x;
        d.y0 = d.y;
      });
    }

    function diagonal(s, d) {
      return `M ${s.x} ${s.y}
              C ${s.x} ${(s.y + d.y) / 2},
                ${d.x} ${(s.y + d.y) / 2},
                ${d.x} ${d.y}`;
    }

    function click(event, d) {
      // Removido o comportamento do clique na caixa
      event.stopPropagation();
    }

    function downloadSVG() {
      const svgData = document.querySelector("#chart-container svg").outerHTML;
      const svgBlob = new Blob([svgData], {type: "image/svg+xml;charset=utf-8"});
      const svgUrl = URL.createObjectURL(svgBlob);
      const downloadLink = document.createElement("a");
      downloadLink.href = svgUrl;
      downloadLink.download = "organograma_ministerio_saude.svg";
      document.body.appendChild(downloadLink);
      downloadLink.click();
      document.body.removeChild(downloadLink);
    }

    function zoomIn() {
      d3.select("#chart-container svg").transition().duration(500).call(zoom.scaleBy, 1.2);
    }

    function zoomOut() {
      d3.select("#chart-container svg").transition().duration(500).call(zoom.scaleBy, 0.8);
    }

    function resetZoom() {
      d3.select("#chart-container svg")
        .transition()
        .duration(750)
        .call(zoom.transform, d3.zoomIdentity);
    }

    document.getElementById('file-input').addEventListener('change', loadCSVFile);
    document.getElementById('expand-all-btn').addEventListener('click', function() {
      if (root) {
        console.log("Expandindo todos os nós");
        expandAll(root);
        update(root);
      }
    });
    document.getElementById('collapse-all-btn').addEventListener('click', function() {
      if (root) {
        // Colapsar recursivamente todos os nós
        function collapseAll(node) {
          if (node.children) {
            node.children.forEach(collapseAll);
            node._children = node.children;
            node.children = null;
          }
        }
        collapseAll(root);
        update(root);
      }
    });
    document.getElementById('download-btn').addEventListener('click', downloadSVG);
    document.getElementById('zoomIn-btn').addEventListener('click', zoomIn);
    document.getElementById('zoomOut-btn').addEventListener('click', zoomOut);
    document.getElementById('resetZoom-btn').addEventListener('click', resetZoom);
  </script>
</body>
</html>
